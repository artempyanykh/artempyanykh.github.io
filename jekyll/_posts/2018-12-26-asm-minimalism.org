# -*- mode: Org; fill-column: 100; -*-

#+TITLE: Bare minimum
#+CATEGORY: asm
#+LAYOUT: page
#+EXCERPT: TODO
#+OPTIONS: toc:nil

A =hello-world= is the gold standard for a minimal program. An implementation usually takes a couple
lines of code in a high(-er) level programming language, and is pretty trivial. However, things that
are happening under the hood are far from being trivial including memory allocation, register and
stack manipulation, and interop with an OS kernel. With that said, going a couple layers down that
stack to the bare assembly in order to build a minimal working program (and a couple other ones)
seemed like fun to me.

* Preliminaries
  First, let's start with a couple =hello-world= implementations: in Haskell and in C. In
  implementation in Haskell is a simple one-liner:
  #+BEGIN_SRC haskell -n :tangle haskell-hello-world.hs
    main = putStrLn "Hello World!"
  #+END_SRC
  We can compile it using =ghc= and run getting the expected output:
  #+BEGIN_SRC shell -n :results verbatim :exports both
    ghc haskell-hello-world.hs -o bin/haskell-hello-world > /dev/null
    bin/haskell-hello-world
    echo $?
  #+END_SRC

  #+RESULTS:
  : Hello World!
  : 0

  An implementation in C is a bit longer, but conceptually not that different:
  #+NAME: c-hello-world
  #+BEGIN_SRC C -n :tangle c-hello-world.c
    #include <stdio.h>

    int main(int argc, const char *argv[])
    {
            printf("Hello World!\n");
            return 0;
    }
  #+END_SRC
  Again, compiling and running this code produces what is expected:
  #+BEGIN_SRC shell -n :results verbatim :exports both
    cc c-hello-world.c -o bin/c-hello-world > /dev/null
    bin/c-hello-world
    echo $?
  #+END_SRC

  #+RESULTS:
  : Hello World!
  : 0

  The C code nicely highlights some of the main points in the program's structure, that will be
  helpful later on, specifically:
  1. We define an entry point into our program called ~main~.
  2. We take command-line arguments in ~argc~ and ~argv~.
  3. We call a function ~printf~ from C standard library that our executable gets linked with.
  4. We return an exit code.

  That's quite a few things, especially for an implementation in assembly. Can we do less, and still
  produce a valid executable? Sure!

  First things first. I'll be using =nasm= and hence Intel's assembly dialect. The code will be
  written for 64-bit MacOS X[fn:1].

#+BEGIN_SRC asm -n :tangle do-nothing-incomplete.asm
          SECTION .text
          GLOBAL _main
  _main:
#+END_SRC

* Footnotes

[fn:1] That fact that it's 64-bit is important as the calling conventions for 32-bit code are quite different.
