---
title:  (╯°□°）╯ ¬¬(A∨¬A)
category: logic
date: 2019-03-21
---

... or "the missing Law of Excluded Middle".

First things first, Law of Excluded Middle or LEM is an axiom of logic
that states that a proposition is either true or false, there is no
third choice. LEM is one of the core tenets of formal reasoning in
"classical" branches of mathematics, and for me as a classically
trained mathematician this is indeed a very natural way of thinking.

Recently, however, I got interested in the theory of programming
languages. The discipline differs a great deal from functional
analysis, probability theory or other familiar branches of
mathematics, and learning required starting from the very basics,
including proof theory and intuitionistic logic.

The latter at first seemed rather bizarre and required (and still
requires) significant un-learning on my side, in part due to absense
of LEM.

Ahead are some basic pieces of intuitionistic logic accompanied by
~Coq~ code to keep the narrative more hand-on.

#+BEGIN_EXPORT html
<!--more-->
#+END_EXPORT

* Propositions, types, True, and False
  Propositions are what logic is made of. It is a factual claim that
  in the context of intuitionistic logic can be proved only by
  providing an evidence or in other words *constructing a proof*.

  #+BEGIN_SRC coq -n
    Check Type.

    Search or.
    Print or_comm.
    Locate "->".
    Print iff.
    Print False.
    Check True.

    Check I.

    Lemma or_comm': forall A B: Prop, A \/ B -> B \/ A.
    Proof.
      intros. apply or_comm in H. exact H.
  #+END_SRC

  #+BEGIN_SRC coq -n
  Lemma or_impl: forall (A B C: Prop),
      ((A \/ B) -> C) -> ((A -> C) /\ (B -> C)).
  Proof.
    intros A B C Habc.
    split.
    - intro Ha.
      pose (pf_AorB := or_introl Ha : A \/ B).
      apply Habc in pf_AorB as pf_C.
      apply pf_C.
    - intro Hb.
      pose (pf_AorB := or_intror Hb : A \/ B).
      apply Habc in pf_AorB as pf_C.
      apply pf_C.
  Qed.
  #+END_SRC

  #+BEGIN_SRC coq -n
  Theorem not_refuting_LEM: forall (A: Prop), ~~(A \/ ~A).
  Proof.
    intro A.
    unfold not.
    intro H_refuteLEM.
    apply or_impl in H_refuteLEM.
    destruct H_refuteLEM as [H_refuteA H_refuteAContradictory].
    apply H_refuteAContradictory in H_refuteA as Contradiction.
    apply Contradiction.
  Qed.
  #+END_SRC
