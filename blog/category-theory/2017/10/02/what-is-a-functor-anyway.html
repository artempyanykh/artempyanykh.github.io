<!DOCTYPE html>
<html>

<head profile="http://www.w3.org/2005/10/profile">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>What is a Functor anyway?</title>
  <meta name="description" content="A functor is a homomorphism of categories.Nice and short definition, but it made absolutely no sense to me.At the time I decided to step up my FP game, I was...">

  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css">

  <link rel="stylesheet" href="/blog/css/main.css">
  <link rel="canonical" href="http://localhost:4000/blog/category-theory/2017/10/02/what-is-a-functor-anyway.html">
  <link rel="alternate" type="application/rss+xml" title="Learning is fun" href="http://localhost:4000/blog/feed.xml">

  <link rel="icon" type="image/png" href="/blog/assets/images/favicon.png">
</head>


<body>


  <header class="header">
    <div class="header-page">

      <span class="header-page-link">
        <svg class="logo"
     data-name="learning is fun - logo"
     xmlns="http://www.w3.org/2000/svg"
     viewBox="0 0 726 726"
     data-href="/blog/"
     xmlns:xlink="http://www.w3.org/1999/xlink">
  <a xlink:href="/blog/">
    <rect id="link-fill" stroke="none" width="726" height="726" rx="47.41" ry="47.41"/>
  </a>

  <title>Learning is fun</title>

  <rect id="bg" width="726" height="726" rx="47.41" ry="47.41"/>

  <g>
    <path id="letter"
          d="M1533.7,1732.64c-9.79-25.5-19.58-51-28.48-81.14h-4.45c-6.23,24.73-17.8,53.32-27.59,78.82l-88.1,216.38h-81.87L1459,1600.49c3.56-8.5,5.34-13.91,5.34-17.77,0-4.64-1.78-11.59-6.23-20.87-27.59-65.68-59.62-117.46-112.12-117.46a105.24,105.24,0,0,0-15.13.77l7.12-52.55c7.12-2.32,19.58-3.09,30.26-3.09,84.54,0,124.58,70.32,170.85,177l164.62,380.2h-82.76Z"
          transform="translate(-1144 -1314)"/>
  </g>
</svg>

      </span>

      <h1 class="header-page-title">What is a Functor anyway?</h1>

    </div>
  </header>

  <main class="main">
    <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

      <div itemprop="articleBody">
        <p><strong>A functor is a homomorphism of categories.</strong>
Nice and short definition, but it made absolutely no sense to me.
At the time I decided to step up my FP game, I was pretty well versed in Scalaz, confidently used Functor, Monad, Applicative and the like.
So, I jumped into a textbook on Category Theory… and got totally stuck.
Something just hadn’t clicked in my mind, I couldn’t map the math to Scalaz code, and instead of being enlightened I only got confused.
Then other things came up, and Cats were put on a back-burner.
The issue as I see it now was in the wrong mindset I developed while being exposed only to the code and internet articles.
Recently, I made another attempt in learning Category Theory which is on-going now and to some extent more successful.</p>

<h2 id="what-is-a-category">What is a category?</h2>
<p>It always helps to go back to basics when feeling confused.
So, let’s start with the most basic thing in Cats, namely the definition of a category.</p>

<p>Formally, a category $\mathscr{C}$ consists of:
\(
    \def\dom{\mathsf{dom}\ }
    \def\cod{\mathsf{cod}\ }
    \def\id{\mathbb{1}}
\)</p>

<ol>
  <li>A collection of objects $C_0 = \{A, B, C, \ldots\}$,</li>
  <li>A collections of arrows<sup id="fnref:morphisms"><a href="#fn:morphisms" class="footnote">1</a></sup> $C_1 = \{f, g, h, \ldots\}$.</li>
</ol>

<p>Each arrow has a domain $\dom f = A \in C_0$ and a codomain $\cod f = B \in C_0$.
This is best visualized with an actual arrow going from $A$ to $B$, that is $A \xrightarrow{f} B$.</p>

<p>For each pair of arrows $f$ and $g$ such that $\cod f = \dom g$ there should exist another arrow $g \circ f$ called <em>a composition</em>.
This operation should be associative, that is
\[
(h \circ g) \circ f = h \circ (g \circ f).
\]</p>

<p>Another important piece in the definition of a category is the existence of an identity arrow.
Formally, for each object $A \in C_0$ there should be an arrow $\id_A: A \rightarrow A$ such that for every arrow $f: A \rightarrow B$ the following holds
\[
f \circ \id_A = \id_B \circ f = f.
\]</p>

<p>From a categorical point of view, objects are not that important, arrow and relationships between them are important.</p>

<p>So far, so good.
Let’s make the last step and figure out what category we’re dealing with as functional programmers. Apparently it has something to do with functions, and actually, that’s pretty much it. Category $\mathscr{L}$<sup id="fnref:lang"><a href="#fn:lang" class="footnote">2</a></sup> defined as follows:</p>

<ul>
  <li>Objects $C_0$ are types of our programming language, like <code class="highlighter-rouge">Int</code>, <code class="highlighter-rouge">Float</code> or <code class="highlighter-rouge">Vector[String]</code>.</li>
  <li>
    <p>Arrows $C_1$ are functions, e.g.</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def f(x: String): Int = x.length
</code></pre></div>    </div>
  </li>
  <li>Composition $\circ$ is a regular function composition.</li>
</ul>

<p>Not really a rocket science, but it takes time to sink in.</p>

<p>It helps to consider another example of a category.
I like to call it $\mathscr{F}lower$.
It consists of one artificial object $O$, and four arrows denoted as $0, 1, 2, 3$, with the composition being addition modulo 4.</p>

<p><img src="/blog/assets/posts/what-is-a-functor/graphs.svg" width="200" alt="Flower category" /></p>

<p>A simple exercise for a reader would be to prove that:</p>

<ol>
  <li>the composition of arrows is associative,</li>
  <li>arrow $0$ is an identity arrow.</li>
</ol>

<p>Just by looking at $\mathscr{L}$ and $\mathscr{F}lower$ it is easy to see that the notion of a <em>category</em> captures a very broad range of subjects.
We as functional programmers are interested in just one category, however, and that is $\mathscr{L}$.</p>

<h2 id="what-is-a-functor">What is a functor?</h2>

<p>In short, functor $F$ is a <em>structure preserving</em> map from category $\mathscr{C} = \{C_0, C_1, \circ_\mathscr{C}\}$ to category $\mathscr{D} = \{D_0, D_1, \circ_\mathscr{D}\}$.
Since categories have objects <strong>and</strong> arrows we actually need two maps here:</p>

<ul>
  <li>$F_0: C_0 \rightarrow D_0$ which maps objects to objects, and</li>
  <li>$F_1: C_1 \rightarrow D_1$ which maps arrows to arrows,</li>
</ul>

<p>We also need laws that capture the essence of being a <em>structure preserving</em> map:</p>

<ol>
  <li>Functor should preserve domain and codomain:
\[
\forall f: A \rightarrow B \in C_1 \implies F_1(f): F_0(A) \rightarrow F_0(B).
\]</li>
  <li>Functor should preserve composition:
\[
\forall f, g \in C_1 \text{where } \cod f = \dom g: F_1 (g \circ_\mathscr{C} f) = F_1(f) \circ_\mathscr{D} F_1(g).
\]</li>
  <li>Functor should preserve identity arrow:
\[
\forall A \in C_0: F_1(\id_A) = \id_{F_0(A)}.
\]</li>
</ol>

<p>This may seem abstract, but not crazy complicated, and it actually starts making sense if you give it enough thinking.</p>

<h2 id="how-do-we-translate-this-to-scala">How do we translate this to Scala?</h2>

<p>First, we need to understand that the only category we’re dealing with is $\mathscr{L}$.
So, every functor $F$ will be from $\mathscr{L}$ to $\mathscr{L}$.
Such functors are called <em>endofunctors</em> <sup id="fnref:endo"><a href="#fn:endo" class="footnote">3</a></sup>.</p>

<p>Let’s translate the definition from the previous section into Scala code.
There are two parts:</p>

<ol>
  <li>Mapping from any type to some other type. This is $F_0$ or “objects to objects”.</li>
  <li>Mapping from any function to some other function. This is $F_1$ or “arrows to arrows”.</li>
</ol>

<p>In the code that looks like this:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Functor</span> <span class="o">{</span>
  <span class="k">type</span> <span class="kt">F0</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
  <span class="k">def</span> <span class="n">F1</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">arrow</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">F0</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="n">F0</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>
<span class="o">}</span>
</code></pre></div></div>

<p>One specific example of a functor would be the following:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">ListFunctor</span> <span class="k">extends</span> <span class="nc">Functor</span> <span class="o">{</span>
  <span class="k">type</span> <span class="kt">F0</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
  <span class="k">def</span> <span class="n">F1</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">arrow</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">F0</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="n">F0</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="n">fa</span> <span class="k">=&gt;</span> <span class="n">fa</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">arrow</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p>It’s relatively easy to check that functor laws hold for this object.</p>

<p>Consider another example:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">NotListFunctor</span> <span class="k">extends</span> <span class="nc">Functor</span> <span class="o">{</span>
  <span class="k">type</span> <span class="kt">F0</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
  <span class="k">def</span> <span class="n">F1</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">arrow</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">F0</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="n">F0</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="n">fa</span> <span class="k">=&gt;</span> <span class="nc">List</span><span class="o">.</span><span class="n">empty</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>
<span class="o">}</span>
</code></pre></div></div>

<p>We have all necessary pieces defined, but the resulting object is not a functor because some of the laws don’t hold.
Give it a minute and think which law doesn’t hold here.</p>

<p>Sometimes when there is a functor defined with <code class="highlighter-rouge">type F0[A] = F[A]</code>, people say that <code class="highlighter-rouge">F</code> is a functor.
This is confusing and not true.
<code class="highlighter-rouge">F[_]</code> is just a type constructor or, in other words, a mapping from any type <code class="highlighter-rouge">A</code> to some other type.
A functor is a thing on its own, and specific <code class="highlighter-rouge">F</code> is just a part of its definition.</p>

<p>An interesting question is whether there is a single functor with <code class="highlighter-rouge">type F0[A] = List[A]</code>.
The answer is <em>yes</em>, and it actually holds true for pretty much every parametric data type.
Fascinating!</p>

<p>One very different example of a functor would be the following:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">IntFunctor</span> <span class="k">extends</span> <span class="nc">Functor</span> <span class="o">{</span>
  <span class="k">type</span> <span class="kt">F0</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Int</span>
  <span class="k">def</span> <span class="n">F1</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">F0</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="n">F0</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="n">x</span> <span class="k">=&gt;</span> <span class="n">x</span>
<span class="o">}</span>
</code></pre></div></div>

<p>We don’t have a parametric data type here.
Instead, we map every type to <code class="highlighter-rouge">Int</code>.
It’s a good exercise to show that this actually is a functor.</p>

<p>Enough with examples.
Let’s compare the definition of a functor above with a simplified version in Scalaz:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">ScalazFunctor</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">map</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>
<span class="o">}</span>
</code></pre></div></div>

<p>It’s close, but not exactly the same.
I think that we end up with <code class="highlighter-rouge">ScalazFunctor</code> instead of <code class="highlighter-rouge">Functor</code> for a couple reasons.
First, if you want to use a functor as an implicit parameter in a function, it’s more convenient to have <code class="highlighter-rouge">F0</code> as a type parameter of a <code class="highlighter-rouge">Functor</code>.
After fixing that we have:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Functor</span><span class="o">[</span><span class="kt">F0</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">F1</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">arrow</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">F0</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="n">F0</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Next issue is with type inference — we need to specify type arguments on every <code class="highlighter-rouge">F1</code> invocation.
If we make <code class="highlighter-rouge">F0[A]</code> the first argument to <code class="highlighter-rouge">F1[A, B]</code> then the compiler will usually figure out <code class="highlighter-rouge">A</code> and <code class="highlighter-rouge">B</code> on its own.
After this change we arrive at:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Functor</span><span class="o">[</span><span class="kt">F0</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">F1</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">f0a</span><span class="k">:</span> <span class="kt">F0</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">arrow</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">F0</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>
<span class="o">}</span>
</code></pre></div></div>

<p>This perfectly matches <code class="highlighter-rouge">ScalazFunctor</code>, the definitions are completely equivalent and <code class="highlighter-rouge">ScalazFunctor</code> is actually more convenient to use.
The downside of the latter definition, in my opinion, is that it hides <em>objects to objects</em> part of a functor definition, and makes relating math and code harder.</p>

<h2 id="conclusion">Conclusion</h2>
<p>At this point, I’m pretty happy with my understanding of basic categorical notions and how to map them to the code.
There are a couple more things that require a deeper dive in, for instance, the notion of <em>structure preserving</em> actually has a precise definition, although it was used rather loosely in this post.
Also, the proof of uniqueness of <code class="highlighter-rouge">ListFunctor</code> and other similar functors is still an open question to me.</p>

<hr />
<hr />

<div class="footnotes">
  <ol>
    <li id="fn:morphisms">
      <p>Arrows are also called morphisms. <a href="#fnref:morphisms" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:lang">
      <p>$\mathscr{L}$ from “<strong>L</strong>anguage”. I’m deliberately avoiding possible complications related to the presence of side-effects and such. <a href="#fnref:lang" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:endo">
      <p><em>Endo</em> stands for “internal/within”. <a href="#fnref:endo" class="reversefootnote">&#8617;</a></p>
    </li>
  </ol>
</div>

      </div>

      <div class="post-meta">
        <time datetime="2017-10-02T00:00:00+03:00" itemprop="datePublished">
          Oct 2, 2017
        </time>
      </div>

    </article>
  </main>

  <footer class="footer">
  <nav class="footer-nav">

    <a class="footer-nav-item" href="/blog/">
      <span class="fa fa-home fa-lg"></span>
    </a>

    <a class="footer-nav-item" href="https://github.com/artempyanykh">
      <span class="fa fa-github fa-lg"></span>
    </a>

    <a class="footer-nav-item" href="https://ru.linkedin.com/in/artempyanykh/en">
      <span class="fa fa-linkedin fa-lg"></span>
    </a>

    <a class="footer-nav-item" href="https://twitter.com/artem_pyanykh">
      <span class="fa fa-twitter fa-lg"></span>
    </a>

    <a class="footer-nav-item" href="/blog/feed.xml">
      <span class="fa fa-rss fa-lg"></span>
    </a>

    <a class="footer-nav-item" href="/blog/about">
      <span class="fa fa-question fa-lg"></span>
    </a>
  </nav>
</footer>


  
    <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ['\\(', '\\)'] ],
      displayMath: [ ['$$','$$'], ['\\[', '\\]'] ],
      processEscapes: true,
    }
  });
</script>
<script type="text/javascript"
          src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

  
</body>

</html>
