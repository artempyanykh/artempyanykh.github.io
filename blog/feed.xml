<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Learning is fun</title>
    <description>Math, programming, productivity -- these are the topics that interest me the most. When I happen to find time I write something interesting on the subject.
</description>
    <link>http://localhost:4000/blog/</link>
    <atom:link href="http://localhost:4000/blog/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Thu, 20 Dec 2018 14:28:49 +0300</pubDate>
    <lastBuildDate>Thu, 20 Dec 2018 14:28:49 +0300</lastBuildDate>
    <generator>Jekyll v3.7.4</generator>
    
      <item>
        <title>Divide, mask, and the power of 2</title>
        <description> &lt;p&gt;Test whether GH-Pages support org mode jekyll plugin.&lt;/p&gt;
&lt;pre class=&quot;src&quot; lang=&quot;asm&quot;&gt;
        %include 'functions.asm'

        GLOBAL _main

        SECTION .data
        msg1 db 'Hello, reusable world!', 0xA
        msg2 db 'I was printed using included subroutines!', 0xA

        SECTION .text
_main:
        lea     rdi, [rel msg1]
        call    print

        lea     rdi, [rel msg2]
        call    print

        ret
&lt;/pre&gt;
&lt;pre class=&quot;src&quot; lang=&quot;C&quot;&gt;

&lt;span style=&quot;color:#088;font-weight:bold&quot;&gt;void&lt;/span&gt; main()
{
    printf(&lt;span style=&quot;background-color:hsla(0,100%,50%,0.05)&quot;&gt;&lt;span style=&quot;color:#710&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#D20&quot;&gt;Hello, world!&lt;/span&gt;&lt;span style=&quot;color:#710&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;);
}

&lt;/pre&gt;
 </description>
        <pubDate>Thu, 20 Dec 2018 00:00:00 +0300</pubDate>
        <link>http://localhost:4000/blog/2018/12/20/divide-mask-pow2.html</link>
        <guid isPermaLink="true">http://localhost:4000/blog/2018/12/20/divide-mask-pow2.html</guid>
        
        
      </item>
    
      <item>
        <title>What is a Functor anyway?</title>
        <description>&lt;p&gt;&lt;strong&gt;A functor is a homomorphism of categories.&lt;/strong&gt;
Nice and short definition, but it made absolutely no sense to me.&lt;br /&gt;
At the time I decided to step up my FP game, I was pretty well versed in Scalaz, confidently used Functor, Monad, Applicative and the like.
So, I jumped into a textbook on Category Theory… and got totally stuck.
Something just hadn’t clicked in my mind, I couldn’t map the math to Scalaz code, and instead of being enlightened I only got confused.
Then other things came up, and Cats were put on a back-burner.&lt;br /&gt;
The issue as I see it now was in the wrong mindset I developed while being exposed only to the code and internet articles.
Recently, I made another attempt in learning Category Theory which is on-going now and to some extent more successful.&lt;/p&gt;

&lt;h2 id=&quot;what-is-a-category&quot;&gt;What is a category?&lt;/h2&gt;
&lt;p&gt;It always helps to go back to basics when feeling confused.
So, let’s start with the most basic thing in Cats, namely the definition of a category.&lt;/p&gt;

&lt;p&gt;Formally, a category $\mathscr{C}$ consists of:
\(
    \def\dom{\mathsf{dom}\ }
    \def\cod{\mathsf{cod}\ }
    \def\id{\mathbb{1}}
\)&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;A collection of objects $C_0 = \{A, B, C, \ldots\}$,&lt;/li&gt;
  &lt;li&gt;A collections of arrows&lt;sup id=&quot;fnref:morphisms&quot;&gt;&lt;a href=&quot;#fn:morphisms&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt; $C_1 = \{f, g, h, \ldots\}$.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Each arrow has a domain $\dom f = A \in C_0$ and a codomain $\cod f = B \in C_0$.
This is best visualized with an actual arrow going from $A$ to $B$, that is $A \xrightarrow{f} B$.&lt;/p&gt;

&lt;p&gt;For each pair of arrows $f$ and $g$ such that $\cod f = \dom g$ there should exist another arrow $g \circ f$ called &lt;em&gt;a composition&lt;/em&gt;.
This operation should be associative, that is 
\[
(h \circ g) \circ f = h \circ (g \circ f).
\]&lt;/p&gt;

&lt;p&gt;Another important piece in the definition of a category is the existence of an identity arrow.
Formally, for each object $A \in C_0$ there should be an arrow $\id_A: A \rightarrow A$ such that for every arrow $f: A \rightarrow B$ the following holds
\[
f \circ \id_A = \id_B \circ f = f.
\]&lt;/p&gt;

&lt;p&gt;From a categorical point of view, objects are not that important, arrow and relationships between them are important.&lt;/p&gt;

&lt;p&gt;So far, so good.
Let’s make the last step and figure out what category we’re dealing with as functional programmers. Apparently it has something to do with functions, and actually, that’s pretty much it. Category $\mathscr{L}$&lt;sup id=&quot;fnref:lang&quot;&gt;&lt;a href=&quot;#fn:lang&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt; defined as follows:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Objects $C_0$ are types of our programming language, like &lt;code class=&quot;highlighter-rouge&quot;&gt;Int&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;Float&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;Vector[String]&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Arrows $C_1$ are functions, e.g.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def f(x: String): Int = x.length
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;Composition $\circ$ is a regular function composition.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Not really a rocket science, but it takes time to sink in.&lt;/p&gt;

&lt;p&gt;It helps to consider another example of a category.
I like to call it $\mathscr{F}lower$.
It consists of one artificial object $O$, and four arrows denoted as $0, 1, 2, 3$, with the composition being addition modulo 4.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/posts/what-is-a-functor/graphs.svg&quot; width=&quot;200&quot; alt=&quot;Flower category&quot; /&gt;&lt;/p&gt;

&lt;p&gt;A simple exercise for a reader would be to prove that:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;the composition of arrows is associative,&lt;/li&gt;
  &lt;li&gt;arrow $0$ is an identity arrow.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Just by looking at $\mathscr{L}$ and $\mathscr{F}lower$ it is easy to see that the notion of a &lt;em&gt;category&lt;/em&gt; captures a very broad range of subjects.
We as functional programmers are interested in just one category, however, and that is $\mathscr{L}$.&lt;/p&gt;

&lt;h2 id=&quot;what-is-a-functor&quot;&gt;What is a functor?&lt;/h2&gt;

&lt;p&gt;In short, functor $F$ is a &lt;em&gt;structure preserving&lt;/em&gt; map from category $\mathscr{C} = \{C_0, C_1, \circ_\mathscr{C}\}$ to category $\mathscr{D} = \{D_0, D_1, \circ_\mathscr{D}\}$.
Since categories have objects &lt;strong&gt;and&lt;/strong&gt; arrows we actually need two maps here:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;$F_0: C_0 \rightarrow D_0$ which maps objects to objects, and&lt;/li&gt;
  &lt;li&gt;$F_1: C_1 \rightarrow D_1$ which maps arrows to arrows,&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We also need laws that capture the essence of being a &lt;em&gt;structure preserving&lt;/em&gt; map:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Functor should preserve domain and codomain:
\[
\forall f: A \rightarrow B \in C_1 \implies F_1(f): F_0(A) \rightarrow F_0(B).
\]&lt;/li&gt;
  &lt;li&gt;Functor should preserve composition:
\[
\forall f, g \in C_1 \text{where } \cod f = \dom g: F_1 (g \circ_\mathscr{C} f) = F_1(f) \circ_\mathscr{D} F_1(g).
\]&lt;/li&gt;
  &lt;li&gt;Functor should preserve identity arrow:
\[
\forall A \in C_0: F_1(\id_A) = \id_{F_0(A)}.
\]&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;This may seem abstract, but not crazy complicated, and it actually starts making sense if you give it enough thinking.&lt;/p&gt;

&lt;h2 id=&quot;how-do-we-translate-this-to-scala&quot;&gt;How do we translate this to Scala?&lt;/h2&gt;

&lt;p&gt;First, we need to understand that the only category we’re dealing with is $\mathscr{L}$.
So, every functor $F$ will be from $\mathscr{L}$ to $\mathscr{L}$.
Such functors are called &lt;em&gt;endofunctors&lt;/em&gt; &lt;sup id=&quot;fnref:endo&quot;&gt;&lt;a href=&quot;#fn:endo&quot; class=&quot;footnote&quot;&gt;3&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;

&lt;p&gt;Let’s translate the definition from the previous section into Scala code.
There are two parts:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Mapping from any type to some other type. This is $F_0$ or “objects to objects”.&lt;/li&gt;
  &lt;li&gt;Mapping from any function to some other function. This is $F_1$ or “arrows to arrows”.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;In the code that looks like this:&lt;/p&gt;

&lt;div class=&quot;language-scala highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;trait&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Functor&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;F0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;F1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;](&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;arrow&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;F0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;F0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;One specific example of a functor would be the following:&lt;/p&gt;

&lt;div class=&quot;language-scala highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ListFunctor&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Functor&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;F0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;F1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;](&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;arrow&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;F0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;F0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fa&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fa&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;arrow&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;It’s relatively easy to check that functor laws hold for this object.&lt;/p&gt;

&lt;p&gt;Consider another example:&lt;/p&gt;

&lt;div class=&quot;language-scala highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;NotListFunctor&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Functor&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;F0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;F1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;](&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;arrow&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;F0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;F0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fa&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;empty&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;We have all necessary pieces defined, but the resulting object is not a functor because some of the laws don’t hold.
Give it a minute and think which law doesn’t hold here.&lt;/p&gt;

&lt;p&gt;Sometimes when there is a functor defined with &lt;code class=&quot;highlighter-rouge&quot;&gt;type F0[A] = F[A]&lt;/code&gt;, people say that &lt;code class=&quot;highlighter-rouge&quot;&gt;F&lt;/code&gt; is a functor.
This is confusing and not true.
&lt;code class=&quot;highlighter-rouge&quot;&gt;F[_]&lt;/code&gt; is just a type constructor or, in other words, a mapping from any type &lt;code class=&quot;highlighter-rouge&quot;&gt;A&lt;/code&gt; to some other type.
A functor is a thing on its own, and specific &lt;code class=&quot;highlighter-rouge&quot;&gt;F&lt;/code&gt; is just a part of its definition.&lt;/p&gt;

&lt;p&gt;An interesting question is whether there is a single functor with &lt;code class=&quot;highlighter-rouge&quot;&gt;type F0[A] = List[A]&lt;/code&gt;.
The answer is &lt;em&gt;yes&lt;/em&gt;, and it actually holds true for pretty much every parametric data type.
Fascinating!&lt;/p&gt;

&lt;p&gt;One very different example of a functor would be the following:&lt;/p&gt;

&lt;div class=&quot;language-scala highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;IntFunctor&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Functor&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;F0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Int&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;F1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;](&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;F0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;F0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;We don’t have a parametric data type here. 
Instead, we map every type to &lt;code class=&quot;highlighter-rouge&quot;&gt;Int&lt;/code&gt;.
It’s a good exercise to show that this actually is a functor.&lt;/p&gt;

&lt;p&gt;Enough with examples.
Let’s compare the definition of a functor above with a simplified version in Scalaz:&lt;/p&gt;

&lt;div class=&quot;language-scala highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;trait&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ScalazFunctor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;](&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fa&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;])(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;It’s close, but not exactly the same.
I think that we end up with &lt;code class=&quot;highlighter-rouge&quot;&gt;ScalazFunctor&lt;/code&gt; instead of &lt;code class=&quot;highlighter-rouge&quot;&gt;Functor&lt;/code&gt; for a couple reasons.
First, if you want to use a functor as an implicit parameter in a function, it’s more convenient to have &lt;code class=&quot;highlighter-rouge&quot;&gt;F0&lt;/code&gt; as a type parameter of a &lt;code class=&quot;highlighter-rouge&quot;&gt;Functor&lt;/code&gt;.
After fixing that we have:&lt;/p&gt;

&lt;div class=&quot;language-scala highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;trait&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Functor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;F0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;F1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;](&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;arrow&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;F0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;F0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Next issue is with type inference — we need to specify type arguments on every &lt;code class=&quot;highlighter-rouge&quot;&gt;F1&lt;/code&gt; invocation.
If we make &lt;code class=&quot;highlighter-rouge&quot;&gt;F0[A]&lt;/code&gt; the first argument to &lt;code class=&quot;highlighter-rouge&quot;&gt;F1[A, B]&lt;/code&gt; then the compiler will usually figure out &lt;code class=&quot;highlighter-rouge&quot;&gt;A&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;B&lt;/code&gt; on its own.
After this change we arrive at:&lt;/p&gt;

&lt;div class=&quot;language-scala highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;trait&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Functor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;F0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;F1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;, &lt;span class=&quot;kt&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;](&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f0a&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;F0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;])(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;arrow&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;F0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This perfectly matches &lt;code class=&quot;highlighter-rouge&quot;&gt;ScalazFunctor&lt;/code&gt;, the definitions are completely equivalent and &lt;code class=&quot;highlighter-rouge&quot;&gt;ScalazFunctor&lt;/code&gt; is actually more convenient to use.
The downside of the latter definition, in my opinion, is that it hides &lt;em&gt;objects to objects&lt;/em&gt; part of a functor definition, and makes relating math and code harder.&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;At this point, I’m pretty happy with my understanding of basic categorical notions and how to map them to the code.
There are a couple more things that require a deeper dive in, for instance, the notion of &lt;em&gt;structure preserving&lt;/em&gt; actually has a precise definition, although it was used rather loosely in this post.
Also, the proof of uniqueness of &lt;code class=&quot;highlighter-rouge&quot;&gt;ListFunctor&lt;/code&gt; and other similar functors is still an open question to me.&lt;/p&gt;

&lt;hr /&gt;
&lt;hr /&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:morphisms&quot;&gt;
      &lt;p&gt;Arrows are also called morphisms. &lt;a href=&quot;#fnref:morphisms&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:lang&quot;&gt;
      &lt;p&gt;$\mathscr{L}$ from “&lt;strong&gt;L&lt;/strong&gt;anguage”. I’m deliberately avoiding possible complications related to the presence of side-effects and such. &lt;a href=&quot;#fnref:lang&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:endo&quot;&gt;
      &lt;p&gt;&lt;em&gt;Endo&lt;/em&gt; stands for “internal/within”. &lt;a href=&quot;#fnref:endo&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</description>
        <pubDate>Mon, 02 Oct 2017 00:00:00 +0300</pubDate>
        <link>http://localhost:4000/blog/category-theory/2017/10/02/what-is-a-functor-anyway.html</link>
        <guid isPermaLink="true">http://localhost:4000/blog/category-theory/2017/10/02/what-is-a-functor-anyway.html</guid>
        
        
        <category>category-theory</category>
        
      </item>
    
  </channel>
</rss>
